#!/usr/bin/env bash
# Script Management System for NixOS
# Category: util
# Description: Provides discovery, execution, and documentation of all system scripts
# Usage: scriptctl <command> [options]
# Examples:
#   scriptctl list
#   scriptctl search backup
#   scriptctl info update-system
#   scriptctl interactive

set -euo pipefail

SCRIPTS_DIR="${SCRIPTS_DIR:-$HOME/.local/bin}"
SCRIPT_NAME="$(basename "$0")"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Helper functions
print_header() {
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${CYAN}  $1${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1" >&2
}

print_info() {
    echo -e "${BLUE}ℹ${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

# Extract script metadata from comments
get_script_description() {
    local script="$1"
    grep -E "^# Description:|^# DESC:" "$script" 2>/dev/null | head -1 | sed 's/^# Description: //; s/^# DESC: //' || echo "No description available"
}

get_script_category() {
    local script="$1"
    grep -E "^# Category:|^# CAT:" "$script" 2>/dev/null | head -1 | sed 's/^# Category: //; s/^# CAT: //' || echo "uncategorized"
}

get_script_usage() {
    local script="$1"
    grep -E "^# Usage:|^# USAGE:" "$script" 2>/dev/null | head -1 | sed 's/^# Usage: //; s/^# USAGE: //'
}

get_script_examples() {
    local script="$1"
    awk '/^# Examples?:/,/^[^#]/ {if (/^# /) print}' "$script" | sed 's/^# //'
}

# List all available scripts
list_scripts() {
    local category="${1:-}"
    
    print_header "Available Scripts"
    
    declare -A categories
    
    # Scan all executable files
    while IFS= read -r -d '' script; do
        if [[ -x "$script" && "$script" != "$0" ]]; then
            local name=$(basename "$script")
            local desc=$(get_script_description "$script")
            local cat=$(get_script_category "$script")
            
            if [[ -z "$category" || "$cat" == "$category" ]]; then
                categories["$cat"]+="  ${GREEN}$name${NC}\n    $desc\n\n"
            fi
        fi
    done < <(find "$SCRIPTS_DIR" -type f -print0 2>/dev/null)
    
    # Print by category
    for cat in $(echo "${!categories[@]}" | tr ' ' '\n' | sort); do
        echo -e "\n${MAGENTA}[$cat]${NC}"
        echo -e "${categories[$cat]}"
    done
}

# Search scripts by name or description
search_scripts() {
    local query="$1"
    
    print_header "Search Results for '$query'"
    
    while IFS= read -r -d '' script; do
        if [[ -x "$script" && "$script" != "$0" ]]; then
            local name=$(basename "$script")
            local desc=$(get_script_description "$script")
            
            if [[ "$name" == *"$query"* ]] || [[ "$desc" == *"$query"* ]]; then
                echo -e "${GREEN}$name${NC}"
                echo -e "  ${desc}"
                echo -e "  Path: ${BLUE}$script${NC}\n"
            fi
        fi
    done < <(find "$SCRIPTS_DIR" -type f -print0 2>/dev/null)
}

# Show detailed information about a script
info_script() {
    local script_name="$1"
    local script_path="$SCRIPTS_DIR/$script_name"
    
    if [[ ! -f "$script_path" ]]; then
        print_error "Script '$script_name' not found"
        return 1
    fi
    
    print_header "Script Information: $script_name"
    
    echo -e "${CYAN}Path:${NC}        $script_path"
    echo -e "${CYAN}Category:${NC}    $(get_script_category "$script_path")"
    echo -e "${CYAN}Description:${NC} $(get_script_description "$script_path")"
    
    local usage=$(get_script_usage "$script_path")
    if [[ -n "$usage" ]]; then
        echo -e "\n${CYAN}Usage:${NC}\n  $usage"
    fi
    
    local examples=$(get_script_examples "$script_path")
    if [[ -n "$examples" ]]; then
        echo -e "\n${CYAN}Examples:${NC}"
        echo "$examples"
    fi
    
    echo -e "\n${CYAN}Permissions:${NC} $(stat -c '%A' "$script_path")"
    echo -e "${CYAN}Size:${NC}        $(stat -c '%s bytes' "$script_path")"
    echo -e "${CYAN}Modified:${NC}    $(stat -c '%y' "$script_path" | cut -d. -f1)"
}

# Interactive script selector using fzf
interactive_select() {
    if ! command -v fzf >/dev/null 2>&1; then
        print_error "fzf is required for interactive mode"
        return 1
    fi
    
    local selected=$(
        while IFS= read -r -d '' script; do
            if [[ -x "$script" && "$script" != "$0" ]]; then
                local name=$(basename "$script")
                local desc=$(get_script_description "$script")
                local cat=$(get_script_category "$script")
                echo -e "$name\t[$cat] $desc"
            fi
        done < <(find "$SCRIPTS_DIR" -type f -print0 2>/dev/null) | \
        fzf --delimiter='\t' --with-nth=1,2 --preview="$0 info {1}" --preview-window=right:60%
    )
    
    if [[ -n "$selected" ]]; then
        local script_name=$(echo "$selected" | cut -f1)
        echo -e "\n${CYAN}Execute${NC} $script_name? [Y/n] "
        read -r confirm
        if [[ -z "$confirm" || "$confirm" == "y" || "$confirm" == "Y" ]]; then
            exec "$SCRIPTS_DIR/$script_name"
        fi
    fi
}

# Show usage
usage() {
    cat << EOF
${CYAN}Script Management System${NC}

${YELLOW}Usage:${NC}
  $SCRIPT_NAME <command> [options]

${YELLOW}Commands:${NC}
  list [category]     List all available scripts, optionally filtered by category
  search <query>      Search scripts by name or description
  info <script>       Show detailed information about a script
  run <script> [args] Execute a script with optional arguments
  interactive         Interactive script selector (requires fzf)
  categories          List all script categories
  help                Show this help message

${YELLOW}Examples:${NC}
  $SCRIPT_NAME list                    # List all scripts
  $SCRIPT_NAME list system             # List only system scripts
  $SCRIPT_NAME search backup           # Search for backup-related scripts
  $SCRIPT_NAME info update-system      # Show info about a specific script
  $SCRIPT_NAME run update-system       # Execute a script
  $SCRIPT_NAME interactive             # Launch interactive selector

${YELLOW}Script Metadata Format:${NC}
  Scripts should include metadata in comments:
    # Category: system
    # Description: Brief description of what the script does
    # Usage: script-name [options]
    # Examples:
    #   script-name --option1
    #   script-name --option2 value

EOF
}

# List categories
list_categories() {
    print_header "Script Categories"
    
    declare -A category_counts
    
    while IFS= read -r -d '' script; do
        if [[ -x "$script" && "$script" != "$0" ]]; then
            local cat=$(get_script_category "$script")
            ((category_counts["$cat"]++))
        fi
    done < <(find "$SCRIPTS_DIR" -type f -print0 2>/dev/null)
    
    for cat in $(echo "${!category_counts[@]}" | tr ' ' '\n' | sort); do
        echo -e "${MAGENTA}$cat${NC} (${category_counts[$cat]} scripts)"
    done
}

# Main command dispatcher
main() {
    if [[ $# -eq 0 ]]; then
        usage
        exit 0
    fi
    
    local command="$1"
    shift
    
    case "$command" in
        list|ls)
            list_scripts "$@"
            ;;
        search|find)
            if [[ $# -eq 0 ]]; then
                print_error "Search query required"
                exit 1
            fi
            search_scripts "$1"
            ;;
        info|show)
            if [[ $# -eq 0 ]]; then
                print_error "Script name required"
                exit 1
            fi
            info_script "$1"
            ;;
        run|exec)
            if [[ $# -eq 0 ]]; then
                print_error "Script name required"
                exit 1
            fi
            local script_name="$1"
            shift
            exec "$SCRIPTS_DIR/$script_name" "$@"
            ;;
        interactive|i)
            interactive_select
            ;;
        categories|cats)
            list_categories
            ;;
        help|--help|-h)
            usage
            ;;
        *)
            print_error "Unknown command: $command"
            echo ""
            usage
            exit 1
            ;;
    esac
}

main "$@"
